{
  "1069": {
    "id": "1069",
    "label": "delayWhen"
  },
  "1118": {
    "id": "1118",
    "label": "that throws an error",
    "options": [
      "a1ef"
    ]
  },
  "1219": {
    "id": "1219",
    "label": "I want to prepend one value",
    "options": [
      "d7fe"
    ]
  },
  "1828": {
    "id": "1828",
    "label": "repeatWhen"
  },
  "1842": {
    "id": "1842",
    "label": "and emit the group as an array",
    "options": [
      "45d5"
    ]
  },
  "1970": {
    "id": "1970",
    "label": "and emit the group as a nested Observable",
    "options": [
      "b397"
    ]
  },
  "2298": {
    "id": "2298",
    "label": "interval"
  },
  "2497": {
    "id": "2497",
    "label": "withLatestFrom"
  },
  "2523": {
    "id": "2523",
    "label": "windowCount"
  },
  "2543": {
    "id": "2543",
    "label": "based on a given amount",
    "options": [
      "2f3d"
    ]
  },
  "2935": {
    "id": "2935",
    "label": "tap"
  },
  "2978": {
    "id": "2978",
    "label": "I want to change the scheduler",
    "options": [
      "fc2b",
      "4673"
    ]
  },
  "3243": {
    "id": "3243",
    "label": "where the silence duration threshold is determined by another Observable",
    "options": [
      "5f8f"
    ]
  },
  "3768": {
    "id": "3768",
    "label": "where time windows are determined by a time duration",
    "options": [
      "6e3f"
    ]
  },
  "4333": {
    "id": "4333",
    "label": "NEVER"
  },
  "4673": {
    "id": "4673",
    "label": "that routes values to observers",
    "options": [
      "dfbe"
    ]
  },
  "4756": {
    "id": "4756",
    "label": "that emits values on a timer",
    "options": [
      "b41a",
      "0292"
    ]
  },
  "4764": {
    "id": "4764",
    "label": "emitted some time in the past",
    "options": [
      "d431"
    ]
  },
  "4812": {
    "id": "4812",
    "label": "Observable",
    "method": "toPromise"
  },
  "5165": {
    "id": "5165",
    "label": "that includes the time past since the last emitted value",
    "options": [
      "63b9"
    ]
  },
  "5819": {
    "id": "5819",
    "label": "and ignore incoming values while the current nested Observable has not yet completed",
    "options": [
      "9d58"
    ]
  },
  "6247": {
    "id": "6247",
    "label": "that iterates",
    "options": [
      "9bf2",
      "b49a",
      "7d71"
    ]
  },
  "6282": {
    "id": "6282",
    "label": "retry"
  },
  "6596": {
    "id": "6596",
    "label": "buffer"
  },
  "6662": {
    "id": "6662",
    "label": "map"
  },
  "6842": {
    "id": "6842",
    "label": "according to a key or object property",
    "options": [
      "8d7b"
    ]
  },
  "7192": {
    "id": "7192",
    "label": "and cancel the previous nested Observable when a new value arrives",
    "options": [
      "260d",
      "138b"
    ]
  },
  "7286": {
    "id": "7286",
    "label": "where the silence duration threshold is determined by a time duration",
    "options": [
      "12bf"
    ]
  },
  "7325": {
    "id": "7325",
    "label": "toArray"
  },
  "7515": {
    "id": "7515",
    "label": "after a period of inactivity",
    "options": [
      "e111",
      "0c9b"
    ]
  },
  "7518": {
    "id": "7518",
    "label": "when another Observable emits",
    "options": [
      "1828"
    ]
  },
  "7552": {
    "id": "7552",
    "label": "I want to ensure there is only one value",
    "options": [
      "355b"
    ]
  },
  "7743": {
    "id": "7743",
    "label": "forkJoin"
  },
  "7911": {
    "id": "7911",
    "label": "I want to be notified when all of them have completed",
    "options": [
      "7743"
    ]
  },
  "8306": {
    "id": "8306",
    "label": "and only the first value",
    "options": [
      "f265"
    ]
  },
  "8654": {
    "id": "8654",
    "label": "pipe"
  },
  "9719": {
    "id": "9719",
    "label": "I want to ignore values",
    "options": [
      "9f79",
      "481a",
      "bcea",
      "8b5a",
      "cad6",
      "84d0"
    ]
  },
  "9871": {
    "id": "9871",
    "label": "if they are exactly the n-th emission",
    "options": [
      "f89d"
    ]
  },
  "e6d1": {
    "id": "e6d1",
    "label": "mapTo"
  },
  "0f71": {
    "id": "0f71",
    "label": "to be a constant value",
    "options": [
      "e6d1"
    ]
  },
  "48f5": {
    "id": "48f5",
    "label": "to be a value calculated through a formula",
    "options": [
      "6662"
    ]
  },
  "d6c2": {
    "id": "d6c2",
    "label": "I want to change each emitted value",
    "options": [
      "0f71",
      "48f5"
    ]
  },
  "0946": {
    "id": "0946",
    "label": "pluck"
  },
  "a369": {
    "id": "a369",
    "label": "I want to pick a property off each emitted value",
    "options": [
      "0946"
    ]
  },
  "a329": {
    "id": "a329",
    "label": "I want to spy the values being emitted without affecting them",
    "options": [
      "2935"
    ]
  },
  "1f4d": {
    "id": "1f4d",
    "label": "filter"
  },
  "83a5": {
    "id": "83a5",
    "label": "based on custom logic",
    "options": [
      "1f4d"
    ]
  },
  "f265": {
    "id": "f265",
    "label": "first"
  },
  "2f3d": {
    "id": "2f3d",
    "label": "take"
  },
  "9cdb": {
    "id": "9cdb",
    "label": "takeWhile"
  },
  "84cc": {
    "id": "84cc",
    "label": "based on custom logic",
    "options": [
      "9cdb"
    ]
  },
  "be69": {
    "id": "be69",
    "label": "if they are at the start of the Observable",
    "options": [
      "8306",
      "2543",
      "84cc"
    ]
  },
  "f89d": {
    "id": "f89d",
    "label": "elementAt"
  },
  "58fb": {
    "id": "58fb",
    "label": "last"
  },
  "1c79": {
    "id": "1c79",
    "label": "and only the last value",
    "options": [
      "58fb"
    ]
  },
  "dbeb": {
    "id": "dbeb",
    "label": "takeLast"
  },
  "602b": {
    "id": "602b",
    "label": "based on a given amount",
    "options": [
      "dbeb"
    ]
  },
  "71d0": {
    "id": "71d0",
    "label": "if they are at the end of the Observable",
    "options": [
      "1c79",
      "602b"
    ]
  },
  "7fff": {
    "id": "7fff",
    "label": "takeUntil"
  },
  "ef1d": {
    "id": "ef1d",
    "label": "until another Observable emits a value",
    "options": [
      "7fff"
    ]
  },
  "a5d8": {
    "id": "a5d8",
    "label": "I want to allow some values to pass",
    "options": [
      "83a5",
      "be69",
      "9871",
      "71d0",
      "ef1d"
    ]
  },
  "ff69": {
    "id": "ff69",
    "label": "ignoreElements"
  },
  "9f79": {
    "id": "9f79",
    "label": "altogether",
    "options": [
      "ff69"
    ]
  },
  "9e72": {
    "id": "9e72",
    "label": "skip"
  },
  "6d71": {
    "id": "6d71",
    "label": "based on a given amount",
    "options": [
      "9e72"
    ]
  },
  "597d": {
    "id": "597d",
    "label": "skipWhile"
  },
  "2c8c": {
    "id": "2c8c",
    "label": "based on custom logic",
    "options": [
      "597d"
    ]
  },
  "481a": {
    "id": "481a",
    "label": "from the start of the Observable",
    "options": [
      "6d71",
      "2c8c"
    ]
  },
  "f4e4": {
    "id": "f4e4",
    "label": "skipLast"
  },
  "bcea": {
    "id": "bcea",
    "label": "from the end of the Observable",
    "options": [
      "f4e4"
    ]
  },
  "f233": {
    "id": "f233",
    "label": "skipUntil"
  },
  "8b5a": {
    "id": "8b5a",
    "label": "until another Observable emits a value",
    "options": [
      "f233"
    ]
  },
  "39db": {
    "id": "39db",
    "label": "distinctUntilChanged"
  },
  "e854": {
    "id": "e854",
    "label": "emitted just before the current value",
    "options": [
      "39db"
    ]
  },
  "d431": {
    "id": "d431",
    "label": "distinct"
  },
  "c823": {
    "id": "c823",
    "label": "according to value equality",
    "options": [
      "e854",
      "4764"
    ]
  },
  "0797": {
    "id": "0797",
    "label": "distinctUntilKeyChanged"
  },
  "8d7b": {
    "id": "8d7b",
    "label": "emitted just before the current value",
    "options": [
      "0797"
    ]
  },
  "cad6": {
    "id": "cad6",
    "label": "that match some previous value",
    "options": [
      "c823",
      "6842"
    ]
  },
  "0351": {
    "id": "0351",
    "label": "throttle"
  },
  "c229": {
    "id": "c229",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "0351"
    ]
  },
  "6e3f": {
    "id": "6e3f",
    "label": "throttleTime"
  },
  "b50f": {
    "id": "b50f",
    "label": "by emitting the first value in each time window",
    "options": [
      "c229",
      "3768"
    ]
  },
  "db32": {
    "id": "db32",
    "label": "audit"
  },
  "0843": {
    "id": "0843",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "db32"
    ]
  },
  "60ec": {
    "id": "60ec",
    "label": "auditTime"
  },
  "4b75": {
    "id": "4b75",
    "label": "where time windows are determined by a time duration",
    "options": [
      "60ec"
    ]
  },
  "cdf8": {
    "id": "cdf8",
    "label": "by emitting the last value in each time window",
    "options": [
      "0843",
      "4b75"
    ]
  },
  "5f8f": {
    "id": "5f8f",
    "label": "debounce"
  },
  "12bf": {
    "id": "12bf",
    "label": "debounceTime"
  },
  "b640": {
    "id": "b640",
    "label": "by emitting the last value as soon as enough silence has occured",
    "options": [
      "3243",
      "7286"
    ]
  },
  "84d0": {
    "id": "84d0",
    "label": "that occur too frequently",
    "options": [
      "b50f",
      "cdf8",
      "b640"
    ]
  },
  "3f34": {
    "id": "3f34",
    "label": "reduce"
  },
  "f4d5": {
    "id": "f4d5",
    "label": "and only output the final computed value",
    "options": [
      "3f34"
    ]
  },
  "8a8e": {
    "id": "8a8e",
    "label": "scan"
  },
  "7ad8": {
    "id": "7ad8",
    "label": "and output the computed values when the source emits a value",
    "options": [
      "8a8e"
    ]
  },
  "ca10": {
    "id": "ca10",
    "label": "mergeScan"
  },
  "50a0": {
    "id": "50a0",
    "label": "and output the computed values as a nested Observable when the source emits a value",
    "options": [
      "ca10"
    ]
  },
  "0f02": {
    "id": "0f02",
    "label": "I want to compute a formula using all values emitted",
    "options": [
      "f4d5",
      "7ad8",
      "50a0"
    ]
  },
  "e1cb": {
    "id": "e1cb",
    "label": "materialize"
  },
  "dfbb": {
    "id": "dfbb",
    "label": "that describes each notification (next, error, or complete)",
    "options": [
      "e1cb"
    ]
  },
  "63b9": {
    "id": "63b9",
    "label": "timeInterval"
  },
  "b9b9": {
    "id": "b9b9",
    "label": "I want to wrap its messages with metadata",
    "options": [
      "dfbb",
      "5165"
    ]
  },
  "520a": {
    "id": "520a",
    "label": "timeout"
  },
  "e111": {
    "id": "e111",
    "label": "I want to throw an error",
    "options": [
      "520a"
    ]
  },
  "bb68": {
    "id": "bb68",
    "label": "timeoutWith"
  },
  "0c9b": {
    "id": "0c9b",
    "label": "I want to switch to another Observable",
    "options": [
      "bb68"
    ]
  },
  "355b": {
    "id": "355b",
    "label": "single"
  },
  "ac0b": {
    "id": "ac0b",
    "label": "count"
  },
  "6a94": {
    "id": "6a94",
    "label": "I want to know how many values it emits",
    "options": [
      "ac0b"
    ]
  },
  "d7fe": {
    "id": "d7fe",
    "label": "startWith"
  },
  "a1ad": {
    "id": "a1ad",
    "label": "delay"
  },
  "f0ce": {
    "id": "f0ce",
    "label": "based on a given amount of time",
    "options": [
      "a1ad"
    ]
  },
  "678e": {
    "id": "678e",
    "label": "based on the emissions of another Observable",
    "options": [
      "1069"
    ]
  },
  "df82": {
    "id": "df82",
    "label": "I want to delay the emissions",
    "options": [
      "f0ce",
      "678e"
    ]
  },
  "eb9a": {
    "id": "eb9a",
    "label": "and convert to an array",
    "options": [
      "7325"
    ]
  },
  "54da": {
    "id": "54da",
    "label": "and convert to a Promise",
    "options": [
      "4812"
    ]
  },
  "d118": {
    "id": "d118",
    "label": "until the Observable completes",
    "options": [
      "eb9a",
      "54da"
    ]
  },
  "65ce": {
    "id": "65ce",
    "label": "pairwise"
  },
  "aff2": {
    "id": "aff2",
    "label": "consecutively in pairs, as arrays",
    "options": [
      "65ce"
    ]
  },
  "0b68": {
    "id": "0b68",
    "label": "partition"
  },
  "8af5": {
    "id": "8af5",
    "label": "based on a criterion, and output two Observables: those that match the criterion and those that do not",
    "options": [
      "0b68"
    ]
  },
  "b8a4": {
    "id": "b8a4",
    "label": "bufferCount"
  },
  "a52d": {
    "id": "a52d",
    "label": "and emit the group as an array",
    "options": [
      "b8a4"
    ]
  },
  "75f6": {
    "id": "75f6",
    "label": "and emit the group as a nested Observable",
    "options": [
      "2523"
    ]
  },
  "7f90": {
    "id": "7f90",
    "label": "in batches of a particular size",
    "options": [
      "a52d",
      "75f6"
    ]
  },
  "96b8": {
    "id": "96b8",
    "label": "bufferTime"
  },
  "ac21": {
    "id": "ac21",
    "label": "and emit the group as an array",
    "options": [
      "96b8"
    ]
  },
  "c9f3": {
    "id": "c9f3",
    "label": "windowTime"
  },
  "948d": {
    "id": "948d",
    "label": "and emit the group as a nested Observable",
    "options": [
      "c9f3"
    ]
  },
  "d113": {
    "id": "d113",
    "label": "based on time",
    "options": [
      "ac21",
      "948d"
    ]
  },
  "448b": {
    "id": "448b",
    "label": "and emit the group as an array",
    "options": [
      "6596"
    ]
  },
  "108b": {
    "id": "108b",
    "label": "window"
  },
  "0e6c": {
    "id": "0e6c",
    "label": "and emit the group as a nested Observable",
    "options": [
      "108b"
    ]
  },
  "c2ff": {
    "id": "c2ff",
    "label": "until another Observable emits",
    "options": [
      "448b",
      "0e6c"
    ]
  },
  "c1dd": {
    "id": "c1dd",
    "label": "bufferWhen"
  },
  "5b88": {
    "id": "5b88",
    "label": "and emit the group as an array",
    "options": [
      "c1dd"
    ]
  },
  "b397": {
    "id": "b397",
    "label": "windowWhen"
  },
  "ab1b": {
    "id": "ab1b",
    "label": "based on the emissions of an Observable created on-demand",
    "options": [
      "5b88",
      "1970"
    ]
  },
  "45d5": {
    "id": "45d5",
    "label": "bufferToggle"
  },
  "b554": {
    "id": "b554",
    "label": "windowToggle"
  },
  "544a": {
    "id": "544a",
    "label": "and emit the group as a nested Observable",
    "options": [
      "b554"
    ]
  },
  "9f71": {
    "id": "9f71",
    "label": "based on another Observable for opening a group, and an Observable for closing a group",
    "options": [
      "1842",
      "544a"
    ]
  },
  "e983": {
    "id": "e983",
    "label": "groupBy"
  },
  "05c2": {
    "id": "05c2",
    "label": "based on a key calculated from the emitted values",
    "options": [
      "e983"
    ]
  },
  "277b": {
    "id": "277b",
    "label": "I want to group the values",
    "options": [
      "d118",
      "aff2",
      "8af5",
      "7f90",
      "d113",
      "c2ff",
      "ab1b",
      "9f71",
      "05c2"
    ]
  },
  "310e": {
    "id": "310e",
    "label": "mergeMapTo"
  },
  "a3ae": {
    "id": "a3ae",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "310e"
    ]
  },
  "0238": {
    "id": "0238",
    "label": "mergeMap"
  },
  "feab": {
    "id": "feab",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "0238"
    ]
  },
  "ff95": {
    "id": "ff95",
    "label": "and emit the values from all nested Observables in parallel",
    "options": [
      "a3ae",
      "feab"
    ]
  },
  "01d6": {
    "id": "01d6",
    "label": "concatMapTo"
  },
  "dd4e": {
    "id": "dd4e",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "01d6"
    ]
  },
  "6b02": {
    "id": "6b02",
    "label": "concatMap"
  },
  "cb27": {
    "id": "cb27",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "6b02"
    ]
  },
  "fa0e": {
    "id": "fa0e",
    "label": "and emit the values from each nested Observable in order",
    "options": [
      "dd4e",
      "cb27"
    ]
  },
  "076a": {
    "id": "076a",
    "label": "switchMapTo"
  },
  "260d": {
    "id": "260d",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "076a"
    ]
  },
  "e592": {
    "id": "e592",
    "label": "switchMap"
  },
  "138b": {
    "id": "138b",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "e592"
    ]
  },
  "9d58": {
    "id": "9d58",
    "label": "exhaustMap"
  },
  "334e": {
    "id": "334e",
    "label": "expand"
  },
  "6f07": {
    "id": "6f07",
    "label": "and recursively start a new Observable for each new value",
    "options": [
      "334e"
    ]
  },
  "c515": {
    "id": "c515",
    "label": "I want to start a new Observable for each value",
    "options": [
      "ff95",
      "fa0e",
      "7192",
      "5819",
      "6f07"
    ]
  },
  "a5d0": {
    "id": "a5d0",
    "label": "I want to perform custom operations",
    "options": [
      "8654"
    ]
  },
  "08cc": {
    "id": "08cc",
    "label": "share"
  },
  "24d1": {
    "id": "24d1",
    "label": "and start it as soon as the first subscriber arrives",
    "options": [
      "08cc"
    ]
  },
  "16c5": {
    "id": "16c5",
    "label": "publish"
  },
  "86bc": {
    "id": "86bc",
    "label": "and start it manually or imperatively",
    "options": [
      "16c5"
    ]
  },
  "8c5d": {
    "id": "8c5d",
    "label": "using a conventional Subject",
    "options": [
      "24d1",
      "86bc"
    ]
  },
  "79e2": {
    "id": "79e2",
    "label": "publishBehavior"
  },
  "5ecc": {
    "id": "5ecc",
    "label": "using a BehaviorSubject",
    "options": [
      "79e2"
    ]
  },
  "1ad9": {
    "id": "1ad9",
    "label": "publishReplay"
  },
  "f731": {
    "id": "f731",
    "label": "using a ReplaySubject",
    "options": [
      "1ad9"
    ]
  },
  "08fe": {
    "id": "08fe",
    "label": "publishLast"
  },
  "29fb": {
    "id": "29fb",
    "label": "using an AsyncSubject",
    "options": [
      "08fe"
    ]
  },
  "0000": {
    "id": "0000",
    "label": "multicast"
  },
  "97cd": {
    "id": "97cd",
    "label": "using a specific subject implementation",
    "options": [
      "0000"
    ]
  },
  "d09a": {
    "id": "d09a",
    "label": "I want to share a subscription between multiple subscribers",
    "options": [
      "8c5d",
      "5ecc",
      "f731",
      "29fb",
      "97cd"
    ]
  },
  "980c": {
    "id": "980c",
    "label": "catchError"
  },
  "420d": {
    "id": "420d",
    "label": "I want to start a new Observable",
    "options": [
      "980c"
    ]
  },
  "fb2c": {
    "id": "fb2c",
    "label": "immediately",
    "options": [
      "6282"
    ]
  },
  "3c4f": {
    "id": "3c4f",
    "label": "retryWhen"
  },
  "43db": {
    "id": "43db",
    "label": "when another Observable emits",
    "options": [
      "3c4f"
    ]
  },
  "d575": {
    "id": "d575",
    "label": "I want to re-subscribe",
    "options": [
      "fb2c",
      "43db"
    ]
  },
  "47ae": {
    "id": "47ae",
    "label": "when an error occurs",
    "options": [
      "420d",
      "d575"
    ]
  },
  "aa99": {
    "id": "aa99",
    "label": "repeat"
  },
  "ea88": {
    "id": "ea88",
    "label": "immediately",
    "options": [
      "aa99"
    ]
  },
  "7e16": {
    "id": "7e16",
    "label": "I want to re-subscribe",
    "options": [
      "ea88",
      "7518"
    ]
  },
  "e3a5": {
    "id": "e3a5",
    "label": "concat"
  },
  "29f5": {
    "id": "29f5",
    "label": "I want to start a new Observable",
    "options": [
      "e3a5"
    ]
  },
  "8aa2": {
    "id": "8aa2",
    "label": "when it completes",
    "options": [
      "7e16",
      "29f5"
    ]
  },
  "d189": {
    "id": "d189",
    "label": "finalize"
  },
  "da26": {
    "id": "da26",
    "label": "when it completes, errors or unsubscribes, I want to execute a function",
    "options": [
      "d189"
    ]
  },
  "1c5f": {
    "id": "1c5f",
    "label": "subscribeOn"
  },
  "fc2b": {
    "id": "fc2b",
    "label": "that routes calls to subscribe",
    "options": [
      "1c5f"
    ]
  },
  "dfbe": {
    "id": "dfbe",
    "label": "observeOn"
  },
  "5c6d": {
    "id": "5c6d",
    "label": "race"
  },
  "e605": {
    "id": "e605",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "5c6d"
    ]
  },
  "3f66": {
    "id": "3f66",
    "label": "merge"
  },
  "c02e": {
    "id": "c02e",
    "label": "I want to output the values from either of them",
    "options": [
      "3f66"
    ]
  },
  "753b": {
    "id": "753b",
    "label": "combineLatest"
  },
  "60c0": {
    "id": "60c0",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "753b"
    ]
  },
  "f762": {
    "id": "f762",
    "label": "using the latest value of each source only when the primary Observable emits",
    "options": [
      "2497"
    ]
  },
  "b7a7": {
    "id": "b7a7",
    "label": "zip"
  },
  "410b": {
    "id": "410b",
    "label": "using each source value only once",
    "options": [
      "b7a7"
    ]
  },
  "dbe2": {
    "id": "dbe2",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "60c0",
      "f762",
      "410b"
    ]
  },
  "cffc": {
    "id": "cffc",
    "label": "I want to combine this Observable with others, and",
    "options": [
      "e605",
      "c02e",
      "dbe2"
    ]
  },
  "f0d7": {
    "id": "f0d7",
    "label": "I have one existing Observable, and",
    "options": [
      "d6c2",
      "a369",
      "a329",
      "a5d8",
      "9719",
      "0f02",
      "b9b9",
      "7515",
      "7552",
      "6a94",
      "1219",
      "df82",
      "277b",
      "c515",
      "a5d0",
      "d09a",
      "47ae",
      "8aa2",
      "da26",
      "2978",
      "cffc"
    ]
  },
  "113c": {
    "id": "113c",
    "label": "race"
  },
  "3e58": {
    "id": "3e58",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "113c"
    ]
  },
  "dd5f": {
    "id": "dd5f",
    "label": "merge"
  },
  "3ca9": {
    "id": "3ca9",
    "label": "I want to output the values from either of them",
    "options": [
      "dd5f"
    ]
  },
  "d6c9": {
    "id": "d6c9",
    "label": "combineLatest"
  },
  "8f40": {
    "id": "8f40",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "d6c9"
    ]
  },
  "dc2c": {
    "id": "dc2c",
    "label": "zip"
  },
  "4b7b": {
    "id": "4b7b",
    "label": "using each source value only once",
    "options": [
      "dc2c"
    ]
  },
  "f909": {
    "id": "f909",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "8f40",
      "4b7b"
    ]
  },
  "b4c4": {
    "id": "b4c4",
    "label": "concat"
  },
  "e024": {
    "id": "e024",
    "label": "I want to subscribe to each in order",
    "options": [
      "b4c4"
    ]
  },
  "2dff": {
    "id": "2dff",
    "label": "I have some Observables to combine together as one Observable, and",
    "options": [
      "3e58",
      "7911",
      "3ca9",
      "f909",
      "e024"
    ]
  },
  "b856": {
    "id": "b856",
    "label": "Observable",
    "method": "create"
  },
  "5d23": {
    "id": "5d23",
    "label": "using custom logic",
    "options": [
      "b856"
    ]
  },
  "aa45": {
    "id": "aa45",
    "label": "generate"
  },
  "b0a8": {
    "id": "b0a8",
    "label": "using a state machine similar to a for loop",
    "options": [
      "aa45"
    ]
  },
  "a1ef": {
    "id": "a1ef",
    "label": "throwError"
  },
  "bfbd": {
    "id": "bfbd",
    "label": "EMPTY"
  },
  "bf9a": {
    "id": "bf9a",
    "label": "that just completes, without emitting values",
    "options": [
      "bfbd"
    ]
  },
  "c2e2": {
    "id": "c2e2",
    "label": "that never emits anything",
    "options": [
      "4333"
    ]
  },
  "bad6": {
    "id": "bad6",
    "label": "fromEvent"
  },
  "08bc": {
    "id": "08bc",
    "label": "coming from the DOM or Node.js or similar",
    "options": [
      "bad6"
    ]
  },
  "b7b4": {
    "id": "b7b4",
    "label": "fromEventPattern"
  },
  "d8e8": {
    "id": "d8e8",
    "label": "that uses an API to add and remove event handlers",
    "options": [
      "b7b4"
    ]
  },
  "c16b": {
    "id": "c16b",
    "label": "from an existing source of events",
    "options": [
      "08bc",
      "d8e8"
    ]
  },
  "ba11": {
    "id": "ba11",
    "label": "from"
  },
  "382b": {
    "id": "382b",
    "label": "from a Promise or an event source",
    "options": [
      "ba11"
    ]
  },
  "1bd0": {
    "id": "1bd0",
    "label": "from"
  },
  "9bf2": {
    "id": "9bf2",
    "label": "over the values in an array",
    "options": [
      "1bd0"
    ]
  },
  "7b5e": {
    "id": "7b5e",
    "label": "range"
  },
  "b49a": {
    "id": "b49a",
    "label": "over values in a numeric range",
    "options": [
      "7b5e"
    ]
  },
  "c654": {
    "id": "c654",
    "label": "of"
  },
  "7d71": {
    "id": "7d71",
    "label": "over prefined values given as arguments",
    "options": [
      "c654"
    ]
  },
  "b41a": {
    "id": "b41a",
    "label": "regularly",
    "options": [
      "2298"
    ]
  },
  "d00a": {
    "id": "d00a",
    "label": "timer"
  },
  "0292": {
    "id": "0292",
    "label": "with an optional initial delay",
    "options": [
      "d00a"
    ]
  },
  "f6b7": {
    "id": "f6b7",
    "label": "defer"
  },
  "f1e1": {
    "id": "f1e1",
    "label": "which is built on demand when subscribed",
    "options": [
      "f6b7"
    ]
  },
  "72ce": {
    "id": "72ce",
    "label": "I want to create a new Observable",
    "options": [
      "5d23",
      "b0a8",
      "1118",
      "bf9a",
      "c2e2",
      "c16b",
      "382b",
      "6247",
      "4756",
      "f1e1"
    ]
  },
  "00b1": {
    "id": "00b1",
    "label": "bindCallback"
  },
  "cb14": {
    "id": "cb14",
    "label": "supporting a conventional callback API",
    "options": [
      "00b1"
    ]
  },
  "cf95": {
    "id": "cf95",
    "label": "bindNodeCallback"
  },
  "02f3": {
    "id": "02f3",
    "label": "supporting Node.js callback style API",
    "options": [
      "cf95"
    ]
  },
  "f6d5": {
    "id": "f6d5",
    "label": "I want to convert a callback to an Observable",
    "options": [
      "cb14",
      "02f3"
    ]
  },
  "2d14": {
    "id": "2d14",
    "label": "I have no Observables yet, and",
    "options": [
      "72ce",
      "f6d5"
    ]
  },
  "initial": {
    "id": "initial",
    "options": [
      "f0d7",
      "2dff",
      "2d14"
    ]
  }
}